/**
 * gcsim/wfpsim Config Generator
 *
 * Generates wfpsim-compatible configuration from Team and Character data.
 * See: https://docs.gcsim.app/reference/config/
 */

import type { Character, Team, Artifact, Substat } from '../../../types';
import {
  toGcsimCharacterKey,
  toGcsimWeaponKey,
  toGcsimArtifactSetKey,
  toGcsimStatKey,
  toGcsimStatValue,
  getArtifactSetConfig,
  PERCENTAGE_STATS,
} from './gcsimKeyMappings';

// ============================================
// Types
// ============================================

export interface GcsimExportOptions {
  /** Number of Monte Carlo iterations (default: 1000) */
  iterations?: number;
  /** Combat duration in seconds (default: 90) */
  duration?: number;
  /** Target enemy level (default: 100) */
  targetLevel?: number;
  /** Target resistance (default: 0.1 = 10%) */
  targetResist?: number;
  /** Swap delay in frames (default: 4) */
  swapDelay?: number;
  /** Include comments in output */
  includeComments?: boolean;
}

interface AggregatedStats {
  hp: number;
  atk: number;
  def: number;
  'hp%': number;
  'atk%': number;
  'def%': number;
  em: number;
  er: number;
  cr: number;
  cd: number;
  'pyro%': number;
  'hydro%': number;
  'electro%': number;
  'cryo%': number;
  'anemo%': number;
  'geo%': number;
  'dendro%': number;
  'phys%': number;
  heal: number;
}

// ============================================
// Main Config Generator
// ============================================

/**
 * Generate a wfpsim-compatible config from team and character data.
 *
 * @param team - The team to export
 * @param characters - Character data for all team members
 * @param options - Export options
 * @returns The gcsim config string
 */
export function generateGcsimConfig(
  team: Team,
  characters: Character[],
  options: GcsimExportOptions = {}
): string {
  const {
    iterations = 1000,
    duration = 90,
    targetLevel = 100,
    targetResist = 0.1,
    swapDelay = 4,
    includeComments = true,
  } = options;

  // Build character map for quick lookup
  const characterMap = new Map<string, Character>();
  for (const char of characters) {
    characterMap.set(char.key, char);
  }

  // Get team characters in order
  const teamCharacters: Character[] = [];
  for (const charKey of team.characterKeys) {
    const char = characterMap.get(charKey);
    if (char) {
      teamCharacters.push(char);
    }
  }

  if (teamCharacters.length === 0) {
    throw new Error('No valid characters found in team');
  }

  const lines: string[] = [];

  // Header comment
  if (includeComments) {
    lines.push(`# Team: ${team.name}`);
    lines.push(`# Generated by Genshin Progress Tracker`);
    lines.push(`# ${new Date().toISOString().split('T')[0]}`);
    lines.push('');
  }

  // Options line
  lines.push(`options iteration=${iterations} duration=${duration} swap_delay=${swapDelay};`);

  // Target line
  lines.push(`target lvl=${targetLevel} resist=${targetResist};`);
  lines.push('');

  // Generate config for each character
  for (const char of teamCharacters) {
    const charConfig = generateCharacterConfig(char, includeComments);
    lines.push(charConfig);
    lines.push('');
  }

  // Active character (first in team)
  const firstCharKey = toGcsimCharacterKey(teamCharacters[0].key);
  lines.push(`active ${firstCharKey};`);
  lines.push('');

  // Rotation placeholder
  if (includeComments) {
    lines.push('# TODO: Add rotation');
    lines.push('# Example rotation:');
    lines.push(`# ${firstCharKey} skill, burst;`);
    lines.push('# See https://docs.gcsim.app/guides/building_a_simulation_basic_tutorial/');
    if (team.rotationNotes) {
      lines.push('');
      lines.push('# Team rotation notes:');
      for (const line of team.rotationNotes.split('\n')) {
        lines.push(`# ${line}`);
      }
    }
  }

  return lines.join('\n');
}

// ============================================
// Character Config Generator
// ============================================

/**
 * Generate gcsim config block for a single character.
 */
function generateCharacterConfig(char: Character, includeComments: boolean): string {
  const charKey = toGcsimCharacterKey(char.key);
  const lines: string[] = [];

  if (includeComments) {
    lines.push(`# ${char.key}`);
  }

  // Character line: char lvl=90/90 cons=0 talent=1,9,9
  const maxLevel = getMaxLevelForAscension(char.ascension);
  lines.push(
    `${charKey} char lvl=${char.level}/${maxLevel} cons=${char.constellation} talent=${char.talent.auto},${char.talent.skill},${char.talent.burst};`
  );

  // Weapon line: add weapon="thecatch" refine=1 lvl=90/90
  if (char.weapon) {
    const weaponKey = toGcsimWeaponKey(char.weapon.key);
    const weaponMaxLevel = getMaxLevelForAscension(char.weapon.ascension);
    lines.push(
      `${charKey} add weapon="${weaponKey}" refine=${char.weapon.refinement} lvl=${char.weapon.level}/${weaponMaxLevel};`
    );
  }

  // Artifact set lines
  if (char.artifacts && char.artifacts.length > 0) {
    const setCounts = getArtifactSetConfig(char.artifacts);
    for (const { setKey, count } of setCounts) {
      const gcsimSetKey = toGcsimArtifactSetKey(setKey);
      lines.push(`${charKey} add set="${gcsimSetKey}" count=${count};`);
    }

    // Stats line: aggregate all artifact stats
    const stats = aggregateArtifactStats(char.artifacts);
    const statsLine = formatStatsLine(charKey, stats);
    if (statsLine) {
      lines.push(statsLine);
    }
  }

  return lines.join('\n');
}

// ============================================
// Stat Aggregation
// ============================================

/**
 * Aggregate all artifact stats (main stats + substats) into a single stats object.
 */
function aggregateArtifactStats(artifacts: Artifact[]): AggregatedStats {
  const stats: AggregatedStats = {
    hp: 0,
    atk: 0,
    def: 0,
    'hp%': 0,
    'atk%': 0,
    'def%': 0,
    em: 0,
    er: 0,
    cr: 0,
    cd: 0,
    'pyro%': 0,
    'hydro%': 0,
    'electro%': 0,
    'cryo%': 0,
    'anemo%': 0,
    'geo%': 0,
    'dendro%': 0,
    'phys%': 0,
    heal: 0,
  };

  for (const artifact of artifacts) {
    // Add main stat
    addStatToAggregate(stats, artifact.mainStatKey, getMainStatValue(artifact));

    // Add substats
    for (const substat of artifact.substats) {
      addStatToAggregate(stats, substat.key, substat.value);
    }
  }

  return stats;
}

/**
 * Add a stat value to the aggregated stats object.
 */
function addStatToAggregate(
  stats: AggregatedStats,
  key: string,
  value: number
): void {
  const gcsimKey = toGcsimStatKey(key) as keyof AggregatedStats;

  if (gcsimKey in stats) {
    // Convert percentage values to decimal if needed
    const convertedValue = PERCENTAGE_STATS.has(key) ? value / 100 : value;
    stats[gcsimKey] += convertedValue;
  }
}

/**
 * Format the stats line for gcsim config.
 * Only includes stats with non-zero values.
 */
function formatStatsLine(charKey: string, stats: AggregatedStats): string | null {
  const parts: string[] = [];

  // Format each stat with appropriate precision
  for (const [key, value] of Object.entries(stats)) {
    if (value === 0) continue;

    // Determine precision based on stat type
    if (key === 'hp' || key === 'atk' || key === 'def' || key === 'em') {
      // Flat stats as integers
      parts.push(`${key}=${Math.round(value)}`);
    } else {
      // Percentage stats with 4 decimal places (already converted to decimal)
      parts.push(`${key}=${value.toFixed(4)}`);
    }
  }

  if (parts.length === 0) {
    return null;
  }

  return `${charKey} add stats ${parts.join(' ')};`;
}

// ============================================
// Main Stat Values
// ============================================

/**
 * Get the main stat value for an artifact based on its level and rarity.
 * Values are for 5-star artifacts at level 20.
 * Lower levels/rarities get scaled values.
 */
function getMainStatValue(artifact: Artifact): number {
  const { mainStatKey, level, rarity } = artifact;

  // Base values for 5-star artifacts at level 20
  const maxValues: Record<string, number> = {
    hp: 4780,
    atk: 311,
    hp_: 46.6,
    atk_: 46.6,
    def_: 58.3,
    eleMas: 186.5,
    enerRech_: 51.8,
    critRate_: 31.1,
    critDMG_: 62.2,
    pyro_dmg_: 46.6,
    hydro_dmg_: 46.6,
    electro_dmg_: 46.6,
    cryo_dmg_: 46.6,
    anemo_dmg_: 46.6,
    geo_dmg_: 46.6,
    dendro_dmg_: 46.6,
    physical_dmg_: 58.3,
    heal_: 35.9,
  };

  const maxValue = maxValues[mainStatKey] || 0;

  // Scale by level (rough approximation)
  const levelMultiplier = level / 20;

  // Scale by rarity (rough approximation)
  const rarityMultipliers: Record<number, number> = {
    5: 1.0,
    4: 0.8,
    3: 0.6,
    2: 0.5,
    1: 0.4,
  };
  const rarityMultiplier = rarityMultipliers[rarity] || 1.0;

  return maxValue * levelMultiplier * rarityMultiplier;
}

/**
 * Get the max level cap for a given ascension level.
 */
function getMaxLevelForAscension(ascension: number): number {
  const caps = [20, 40, 50, 60, 70, 80, 90];
  return caps[Math.min(ascension, 6)] || 90;
}

// ============================================
// Validation
// ============================================

/**
 * Validate that a team has the minimum required data for export.
 */
export function validateTeamForExport(
  team: Team,
  characters: Character[]
): { valid: boolean; errors: string[] } {
  const errors: string[] = [];

  if (!team.characterKeys || team.characterKeys.length === 0) {
    errors.push('Team has no characters');
    return { valid: false, errors };
  }

  const characterMap = new Map<string, Character>();
  for (const char of characters) {
    characterMap.set(char.key, char);
  }

  for (const charKey of team.characterKeys) {
    const char = characterMap.get(charKey);
    if (!char) {
      errors.push(`Character "${charKey}" not found in roster`);
      continue;
    }

    if (!char.weapon) {
      errors.push(`Character "${charKey}" has no weapon equipped`);
    }

    if (!char.artifacts || char.artifacts.length === 0) {
      errors.push(`Character "${charKey}" has no artifacts equipped`);
    }
  }

  return { valid: errors.length === 0, errors };
}

/**
 * Generate a preview of the config (first N lines).
 */
export function generateConfigPreview(
  team: Team,
  characters: Character[],
  maxLines = 20
): string {
  try {
    const fullConfig = generateGcsimConfig(team, characters, { includeComments: true });
    const lines = fullConfig.split('\n');

    if (lines.length <= maxLines) {
      return fullConfig;
    }

    return lines.slice(0, maxLines).join('\n') + '\n... (truncated)';
  } catch (error) {
    return `Error generating preview: ${error instanceof Error ? error.message : 'Unknown error'}`;
  }
}
